using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;

namespace WeQueryableGeneratorExtensions
{
    [Generator]
    public class MapQueryToPredicateGenerator : ISourceGenerator
    {
        public void Execute(GeneratorExecutionContext context)
        {

            var source = new StringBuilder();
            var syntaxTrees = context.Compilation.SyntaxTrees;


            int indent = 1;
            var receiver = (ClassSyntaxreceiver)context.SyntaxReceiver;
            
            source.AppendLine("// <auto-generated/>");
            source.AppendLine("// Common usings");
            source.AppendLine("using System;");
            source.AppendLine("using System.Linq;");
            source.AppendLine("using System.Collections.Generic;");
            source.AppendLine("using System.Linq.Expressions;");

            source.AppendLine(2);

            var namespaces = receiver.ClassMappings.Select(x => x.Namespace).Where(x => !string.IsNullOrEmpty(x)).Distinct().ToList();
            source.AppendLine("//Mapping Namespaces");
            foreach (var @namespace in namespaces)
            {
                source.AppendLine($"using {@namespace};");
            }
            source.AppendLine(5);
            //source.AppendLine("namespace WeUtilities");
            //source.OpenBrace(indent++);
            source.Comment();
            source.Comment("Extensions Methods for mapping Queries into IQueryable");
            source.Comment();

            source.AppendLine("public static class MapQueryToPredicateExtensions{");

            for (int i = 0; i < receiver.ClassMappings.Count; i++)
            {
                Clazz clazz = receiver.ClassMappings[i];
                List<string> predicates = new();
                source.AppendLine(indent, $"public static Expression<Func<{clazz.Name},bool>> GetPredicate(this {clazz.Name} queryDto)");
                source.OpenBrace(indent);
                for (int j = 0; j < clazz.Properties.Count; j++)
                {
                    var prop = clazz.Properties[j];
                    predicates.Add(prop.FormatPredicate("queryDto"));
                }
                if (predicates.Count > 0)
                {
                    string v = string.Join(@" && ", predicates.Where(x => !string.IsNullOrEmpty(x)));
                    v = string.IsNullOrEmpty(v) ? "true" : v;
                    source.AppendLine(++indent, $"return x =>{v};");
                }
                else
                    source.AppendLine(++indent, "return x=>true;");
                source.CloseBrace(--indent);

                source.AppendLine(indent, $"public static IQueryable<{clazz.Name}> Filter(this IQueryable<{clazz.Name}> queryable, {clazz.Name} queryDto)");
                source.OpenBrace(indent);
                source.AppendLine(++indent, "return queryable.Where(GetPredicate(queryDto));");
                source.CloseBrace(--indent);


            }

            source.CloseBrace(indent--);
            //source.CloseBrace(indent);

            context.AddSource("MapQueryToPredicate.g.cs", SourceText.From(source.ToString(), Encoding.UTF8));
            File.WriteAllText(@"e:\mapped.txt", source.ToString());

        }

        public void Initialize(GeneratorInitializationContext context)
        {
                
     /* #if DEBUG
                  if (!Debugger.IsAttached)
                      Debugger.Launch();
      #endif*/
            context.RegisterForSyntaxNotifications(() => new ClassSyntaxreceiver());
        }
    }
}

public class ClassSyntaxreceiver : ISyntaxReceiver
{
    public List<Clazz> ClassMappings { get; } = new();

    public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
    {
        if (syntaxNode is not ClassDeclarationSyntax cds)
            return;

        if (!cds.AttributeLists.Any(x => x.Attributes.Any(x => x.Name.ToString() == "Queryable")))
            return;

        var properties = cds.Members
            .Select(x => x as PropertyDeclarationSyntax)
            .Where(x => x != null)
            .Select(x => (x.Type.ToString(), x.Identifier.Text))
            .ToList();
        string @namespace = cds.GetNamespaceFrom();
        ClassMappings.Add(new Clazz(@namespace, cds.Identifier.Text, properties));
    }
}


public class Clazz
{

    public Clazz(string @namespace, string name, List<(string, string)> properties)
    {
        this.Namespace = @namespace;
        this.Name = name;
        this.Properties = properties;
    }
    public string Namespace { get; }
    public string Name { get; }
    public List<(string, string)> Properties { get; }

}

public static class StringBuilderExtensions
{
    public static StringBuilder AppendLine(this StringBuilder builder, int count)
    {
        for (int i = 0; i < count; i++)
        {
            builder.AppendLine();
        }
        return builder;
    }
    public static StringBuilder AppendLine(this StringBuilder builder, int tab, string text)
    => builder.AddIndent(tab).AppendLine(text);

    public static StringBuilder AddIndent(this StringBuilder builder, int indent)
        => indent <= 0 ? builder : builder.Append(new string('\t', indent));
    public static StringBuilder OpenBrace(this StringBuilder builder, int indent)
    => builder.AppendLine(indent, "{");
    public static StringBuilder CloseBrace(this StringBuilder builder, int indent)
    => builder.AppendLine(indent, "}");
    public static StringBuilder Comment(this StringBuilder builder, int indent, string comment = "")
    {
        if (string.IsNullOrEmpty(comment))
            builder.AppendLine(indent, "/// <summary>");
        else
            builder.AppendLine(indent, $"/// {comment}");
        return builder;
    }
    public static StringBuilder Comment(this StringBuilder builder, string comment = "") => builder.Comment(0, comment);


    public static string FormatPredicate(this (string, string) item, string queryName)
    {

        if (string.Equals(item.Item1, "string", StringComparison.CurrentCultureIgnoreCase))
            return $"(string.IsNullOrEmpty( {queryName}.{item.Item2})?true:{queryName}.{item.Item2}==x.{item.Item2})";

        return string.Empty;
    }
}

public static class SyntaxExtensions
{

    public static string GetNamespaceFrom(this SyntaxNode s) =>
        s.Parent switch
        {
            NamespaceDeclarationSyntax namespaceDeclarationSyntax => namespaceDeclarationSyntax.Name.ToString(),
            FileScopedNamespaceDeclarationSyntax fnamespaceDeclarationSyntax => fnamespaceDeclarationSyntax.Name.ToString(),
            null => string.Empty, // or whatever you want to do
            _ => s.Parent.GetNamespaceFrom()
        };
}