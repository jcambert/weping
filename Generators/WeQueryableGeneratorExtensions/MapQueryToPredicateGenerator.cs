using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;

namespace WeQueryableGeneratorExtensions
{
    [Generator]
    public class MapQueryToPredicateGenerator : ISourceGenerator
    {
        private const string DEFAULT_NAMESPACE = "WeUtilities";

        public void Execute(GeneratorExecutionContext context)
        {

            var module = context.Compilation
            .SyntaxTrees
            .SelectMany(syntaxTree => syntaxTree.GetRoot().DescendantNodes())
            .Where(x => x is ClassDeclarationSyntax)
            .Cast<ClassDeclarationSyntax>()
            .Where(c => c.Identifier.ValueText.EndsWith("Module", StringComparison.OrdinalIgnoreCase))
            .FirstOrDefault();
            var mainNamespace = module?.GetNamespaceFrom();

            var source = new StringBuilder();
            var syntaxTrees = context.Compilation.SyntaxTrees;


            int indent = 1;
            var receiver = (QueryableClassSyntaxreceiver)context.SyntaxReceiver;

            source.AppendLine("// <auto-generated/>");
            source.AppendLine("// Common usings");
            source.AppendLine("using System;");
            source.AppendLine("using System.Linq;");
            source.AppendLine("using System.Collections.Generic;");
            source.AppendLine("using System.Linq.Expressions;");

            source.AppendLine(2);

            var namespaces = receiver.ClassMappings.Select(x => x.Namespace).Where(x => !string.IsNullOrEmpty(x)).Distinct().ToList();
            source.AppendLine("//Mapping Namespaces");
            foreach (var @namespace in namespaces)
            {
                source.AppendLine($"using {@namespace};");
            }
            source.AppendLine(5);
            source.AppendLine($"namespace {mainNamespace ?? DEFAULT_NAMESPACE}");
            source.OpenBrace(indent++);
            source.Comment();
            source.Comment("Extensions Methods for mapping Queries into IQueryable");
            source.Comment();

            source.AppendLine("public static class MapQueryToPredicateExtensions{");

            for (int i = 0; i < receiver.ClassMappings.Count; i++)
            {
                Clazz clazz = receiver.ClassMappings[i];
                List<string> predicates = new();
                source.AppendLine(indent, $"public static Expression<Func<{clazz.Name},bool>> GetPredicate(this {clazz.Name} queryDto)");
                source.OpenBrace(indent);
                for (int j = 0; j < clazz.Properties.Count; j++)
                {
                    var prop = clazz.Properties[j];
                    predicates.Add(prop.FormatPredicate("queryDto"));
                }
                if (predicates.Count > 0)
                {
                    string v = string.Join(@" && ", predicates.Where(x => !string.IsNullOrEmpty(x)));
                    v = string.IsNullOrEmpty(v) ? "true" : v;
                    source.AppendLine(++indent, $"return x =>{v};");
                }
                else
                    source.AppendLine(++indent, "return x=>true;");
                source.CloseBrace(--indent);

                source.AppendLine(indent, $"public static IQueryable<{clazz.Name}> Filter(this IQueryable<{clazz.Name}> queryable, {clazz.Name} queryDto)");
                source.OpenBrace(indent);
                source.AppendLine(++indent, "return queryable.Where(GetPredicate(queryDto));");
                source.CloseBrace(--indent);


            }

            source.CloseBrace(--indent);
            source.CloseBrace(--indent);

            context.AddSource("MapQueryToPredicate.g.cs", SourceText.From(source.ToString(), Encoding.UTF8));
//            File.WriteAllText(@"e:\mapped.txt", source.ToString());

        }

        public void Initialize(GeneratorInitializationContext context)
        {

            /*#if DEBUG
                         if (!Debugger.IsAttached)
                             Debugger.Launch();
             #endif*/
            context.RegisterForSyntaxNotifications(() => new QueryableClassSyntaxreceiver());
        }
    }

    internal class QueryableClassSyntaxreceiver : ISyntaxReceiver
    {
        internal List<Clazz> ClassMappings { get; } = new();

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            if (syntaxNode is not ClassDeclarationSyntax cds)
                return;

            if (!cds.AttributeLists.Any(x => x.Attributes.Any(x => x.Name.ToString() == "Queryable")))
                return;

            var properties = cds.Members
                .Select(x => x as PropertyDeclarationSyntax)
                .Where(x => x != null)
                .Select(x => (x.Type.ToString(), x.Identifier.Text))
                .ToList();
            string @namespace = cds.GetNamespaceFrom();
            ClassMappings.Add(new Clazz(@namespace, cds.Identifier.Text, properties));
        }
    }


    internal class Clazz
    {

        public Clazz(string @namespace, string name, List<(string, string)> properties)
        {
            this.Namespace = @namespace;
            this.Name = name;
            this.Properties = properties;
        }
        public string Namespace { get; }
        public string Name { get; }
        public List<(string, string)> Properties { get; }

    }

}